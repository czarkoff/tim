#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (c) 2011 Dmitrij D. Czarkoff <czarkoff@gmail.com>
# 
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import os.path, re, sys, Tkinter
from PIL import Image, ImageTk

def phelp(detailed=False):
    sys.stdout.write("{0} {1}\n".format(progname, __version__))
    sys.stdout.write("usage: {0} infile [-c GEOMERTY] [-r ANGLE] [-s GEOMETRY] outfile\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("options (filters):\n")
    sys.stdout.write("  -c GEOMETRY  crop an area with the specified GEOMETRY from image\n")
    sys.stdout.write("  -f           flip image horizontally\n")
    sys.stdout.write("  +f           flip image vertically\n")
    sys.stdout.write("  -r ANGLE     rotate an image ANGLE degrees clockwise\n")
    sys.stdout.write("  -s GEOMETRY  scale an image to GEOMETRY\n")
    if not detailed:
        sys.stdout.write("  -h           print detailed help\n")
        return
    sys.stdout.write("  -h           print this help\n")
    sys.stdout.write("\n")
    sys.stdout.write("GEOMETRY for \"-s\" (scale) operation can be secified as:\n")
    sys.stdout.write("  * XxY (X and Y are either absolute values or percentages)\n")
    sys.stdout.write("  * X,Y\n")
    sys.stdout.write("\n")
    sys.stdout.write("By default, the \"-s\" (scale) operation doesn't maintain aspect ratio of image.\n")
    sys.stdout.write("When GEOMETRY is specified as XxY with absolute values, this behaviour may be \n")
    sys.stdout.write("overriden using postfixes \"A\" (new dimentions are at least as specified) or \"a\"\n")
    sys.stdout.write("(new dimentions are at most as specified).\n")
    sys.stdout.write("\n")
    sys.stdout.write("GEOMETRY for \"-c\" (crop) operation can be secified as:\n")
    sys.stdout.write("\n")
    sys.stdout.write("  * XxY (X and Y are either absolute values or percentages)\n")
    sys.stdout.write("  * A,B,C,D\n")
    sys.stdout.write("\n")
    sys.stdout.write("The two-value spec can be ammended with \"c\" postfix to specify that the area\n")
    sys.stdout.write("should be croped from center of image. Another way to specify area is to add a\n")
    sys.stdout.write("pair of offsets in form of two subsequent signed numbers, first being the\n")
    sys.stdout.write("horizontal offset (positive - from left, negative - from right), second -\n")
    sys.stdout.write("the vertical one (positive - from top, negative - from bottom). Elsewise the UI\n")
    sys.stdout.write("will be brough up help You choose the crp area position\n")
    sys.stdout.write("\n")
    sys.stdout.write("The four-value spec is taken as coordinates of topleft and bottomright pixels\n")
    sys.stdout.write("(A,B)(C,D) of crop area. C must be greater then A, D must be greater then B.\n")
    sys.stdout.write("\n")
    sys.stdout.write("Every operation is performed on result of previous operation.\n")
    sys.stdout.write("\n")
    sys.stdout.write("Correct {0} invokation examples:\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("$ {0} old.jpg -s 500x700 -r 90 -c 100x100+20-10 -s 500x700A +f new.png\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("  1. scale image to dimensions 500x700 regardless initial aspect ratio;\n")
    sys.stdout.write("  2. rotate the result 90 degrees clockwise;\n")
    sys.stdout.write("  3. from the result crop the 100x100 area offset by 20 from left and 10 from\n")
    sys.stdout.write("     bottom;\n")
    sys.stdout.write("  4. scale the result maintaining its aspect ratio to make its width no less;\n")
    sys.stdout.write("     then 500 and its height no less then 700\n")
    sys.stdout.write("  5. flip the result vertically;\n")
    sys.stdout.write("  6. export the result to file new.png in PNG format.\n")
    sys.stdout.write("\n")
    sys.stdout.write("$ {0} file.jpg -c 50%x50% file.jpg\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("Bring up UI to choose the position to crop 50%x50% area and crop it *IN PLACE*.\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("$ {0} old.jpg new.png\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("Convert image from JPEG to PNG format.\n".format(progname))
    
def perror(error):
    sys.stderr.write(progname + ": " + error + "\n")

class CropPhoto(Tkinter.Frame):
    def __init__(self, master, status, img, left, upper, right, lower, buttons=False, **kw):
        self.state = True
        self.img = img
        self.status = status

        if not buttons:
            self.status.set(1)

        self.left = left
        self.upper = upper
        self.right = right
        self.lower = lower

        self.pleft = self.left.get()
        self.pupper = self.upper.get()
        self.pright = self.right.get()
        self.plower = self.lower.get()
        
        self.bbox = img.getbbox()

        Tkinter.Frame.__init__(self, master, **kw)
        self.etop = Tkinter.Entry(self, textvariable=self.upper, width=5)
        self.etop.grid(row=0, column=1)
        
        self.eleft = Tkinter.Entry(self, textvariable=self.left, width=5)
        self.eleft.grid(row=1, column=0)

        self.canvas = Tkinter.Canvas(self, width=img.getbbox()[2], height=img.getbbox()[3])
        self.photo = ImageTk.PhotoImage(self.img)
        self.canvas.create_image(0, 0, anchor=Tkinter.NW, image = self.photo);
        self.canvas.grid(row=1, column=1)

        self.rect = self.canvas.create_rectangle(self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())
        self.canvas.bind("<B1-Motion>", self.bp)
        self.canvas.bind("<ButtonRelease-1>", self.br)

        self.eright = Tkinter.Entry(self, textvariable=self.right, width=5)
        self.eright.grid(row=1, column=2)

        self.ebottom = Tkinter.Entry(self, textvariable=self.lower, width=5)
        self.ebottom.grid(row=2, column=1)

        self.eleft.bind("<Key>", self.left_key)
        self.etop.bind("<Key>", self.upper_key)
        self.eright.bind("<Key>", self.right_key)
        self.ebottom.bind("<Key>", self.lower_key)

        self.eleft.bind("<Return>", self.left_value)
        self.etop.bind("<Return>", self.upper_value)
        self.eright.bind("<Return>", self.right_value)
        self.ebottom.bind("<Return>", self.lower_value)

        self.b_cancel = Tkinter.Button(self, text="Abort", command=self.cancel)
        self.b_crop = Tkinter.Button(self, text="Crop", command=self.crop)
        
        if buttons:
            self.b_cancel.grid(row=2, column=0)
            self.b_crop.grid(row=2, column=2)

    def chkpair(self, a, b):
        if a.get() < 0:
            b.set(b.get() + a.get())
            a.set(0)
        elif b.get() < 0:
            a.set(a.get() + b.get())
            b.set(0)

    def bp(self, event):
        canvas = event.widget   
        if self.state:
            self.state = False
            self.x = canvas.canvasx(event.x)
            self.y = canvas.canvasy(event.y)
        else:
            x = int(canvas.canvasx(event.x) - self.x)
            y = int(canvas.canvasy(event.y) - self.y)
            self.x = canvas.canvasx(event.x)
            self.y = canvas.canvasy(event.y)
            self.left.set(self.left.get() + x)
            self.upper.set(self.upper.get() + y)
            self.right.set(self.right.get() - x)
            self.lower.set(self.lower.get() - y)
            self.chkpair(self.left, self.right)
            self.chkpair(self.upper, self.lower)
            self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def br(self, event):
        self.state = True
        
    def left_value(self, event):
        self.right.set(self.right.get() - self.left.get() + self.pleft)
        self.chkpair(self.left, self.right)
        self.pleft = self.left.get()
        self.pright = self.right.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def upper_value(self, event):
        self.lower.set(self.lower.get() - self.upper.get() + self.pupper)
        self.chkpair(self.upper, self.lower)
        self.pupper = self.upper.get()
        self.plower = self.lower.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def right_value(self, event):
        self.left.set(self.left.get() - self.right.get() + self.pright)
        self.chkpair(self.left, self.right)
        self.pleft = self.left.get()
        self.pright = self.right.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def lower_value(self, event):
        self.upper.set(self.upper.get() - self.lower.get() + self.plower)
        self.chkpair(self.upper, self.lower)
        self.pupper = self.upper.get()
        self.plower = self.lower.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def left_key(self, event):
        if event.keysym == "Up":
            self.left.set(self.left.get() + 1)
        if event.keysym == "Down":
            self.left.set(self.left.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.left_value(event)

    def upper_key(self, event):
        if event.keysym == "Up":
            self.upper.set(self.upper.get() + 1)
        if event.keysym == "Down":
            self.upper.set(self.upper.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.upper_value(event)

    def right_key(self, event):
        if event.keysym == "Up":
            self.right.set(self.right.get() + 1)
        if event.keysym == "Down":
            self.right.set(self.right.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.right_value(event)

    def lower_key(self, event):
        if event.keysym == "Up":
            self.lower.set(self.lower.get() + 1)
        if event.keysym == "Down":
            self.lower.set(self.lower.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.lower_value(event)

    def cancel(self):
        self.quit()

    def crop(self):
        self.status.set(1)
        self.quit()

def edit(img, geometry):
    root = Tkinter.Tk()
    
    status = Tkinter.IntVar()
    left = Tkinter.IntVar()
    upper = Tkinter.IntVar()
    right = Tkinter.IntVar()
    lower = Tkinter.IntVar()
    
    bbox = img.getbbox()
    
    status.set(0)
    left.set(0)
    upper.set(0)
    right.set(bbox[2] - geometry[0])
    lower.set(bbox[3] - geometry[1])
    resizer = CropPhoto(root, status, img, left, upper, right, lower, buttons=True)
    resizer.pack()

    root.mainloop()

    if status.get() == 1:
        return (left.get(), upper.get(), bbox[2]-right.get(), bbox[3]-lower.get())
    else:
        return

def crop_geometry(spec, bbox):
    geometry =  re.match("([0-9]+),([0-9]+),([0-9]+),([0-9]+)", spec)
    if geometry != None:
        geometry = geometry.groups()
        left = int(geometry[0])
        upper = int(geometry[1])
        right = int(geometry[2])
        lower = int(geometry[3])

    else:
        geometry = re.match("([0-9]+x[0-9]+|[0-9]+%x[0-9]+%)([\+\-][0-9]+)([\+\-][0-9]+)", spec) or re.match("([0-9]+x[0-9]+|[0-9]+%x[0-9]+%)(c)", spec) or re.match("([0-9]+x[0-9]+|[0-9]+%x[0-9]+%)", spec)
    
        if (geometry == None):
            raise ValueError("malformed spec \"{0}\"".format(spec))
        else:
            geometry = geometry.groups()

        if (len(geometry) == 1):
            x, y = base_geometry(geometry[0], bbox)

            return ("edit", x, y)

        elif (len(geometry) == 2):
            x, y = base_geometry(geometry[0], bbox)

            left = (bbox[2] - x) / 2
            upper = (bbox[3] - y) / 2
            right = bbox[2] - left
            lower = bbox[3] - upper

        elif (len(geometry) == 3):
            x, y = base_geometry(geometry[0], bbox)

            if geometry[1][0] == "-":
                left = bbox[2] - x - int(geometry[1][1:])
            elif geometry[1][0] == "+":
                left = int(geometry[1][1:])
            else:
                raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))
            right = left + x

            if geometry[2][0] == "-":
                upper = bbox[3] - y - int(geometry[2][1:])
            elif spec[2][0] == "+":
                upper = int(geometry[2][1:])
            else:
                raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))
            lower = upper + y

        else:
            raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))
        
    return (left, upper, right, lower)

def resize_geometry(spec, bbox):
    inset = False
    outset = False

    geometry = re.match("([0-9]+),([0-9]+)", spec)
    if geometry != None:
        x = int(geometry.group(1))
        y = int(geometry.group(2))

    else:
        geometry = re.match("([0-9]+x[0-9]+)(A|a)?", spec) or re.match("([0-9]+%x[0-9]+%)", spec)
        
        if geometry != None:
            geometry = geometry.groups()
        else:
            raise ValueError("malformed spec \"{0}\"".format(spec))

        if len(geometry) == 2:
            if geometry[1] == "A":
                outset = True
            elif geometry[1] == "a":
                inset = True
            elif geometry[1] == None:
                pass
            else:
                raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))

        x, y = base_geometry(geometry[0], bbox)
        
        if inset or outset:
            if (bbox[2]*y/bbox[3] > x):
                if inset:
                    y = bbox[3]*x / bbox[2]
                elif outset:
                    x = bbox[2]*y / bbox[3]
            elif (bbox[3]*x/bbox[2] > y):
                if inset:
                    x = bbox[2]*y / bbox[3]
                elif outset:
                    y = bbox[3]*x / bbox[2]

    return (x, y)

def base_geometry(spec, bbox):
    geometry = re.match("([0-9]+)x([0-9]+)", spec) or re.match("([0-9]+)%x([0-9]+)(%)", spec)
    if geometry == None:
        raise ValueError("malformed spec \"{0}\"".format(spec))
    else:
        geometry = geometry.groups()
        if len(geometry) == 2:
            x = int(geometry[0])
            y = int(geometry[1])
        elif len(geometry) == 3:
            x = bbox[2] * int(geometry[0]) / 100
            y = bbox[3] * int(geometry[1]) / 100
        else:
            raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))
        
    return (x, y)

__version__ = "2-beta"

progname = os.path.basename(sys.argv.pop(0))

if len(sys.argv) == 0:
    phelp()
    sys.exit(0)

elif sys.argv[0] == "-h":
    phelp(detailed=True)
    sys.exit(0)

if sys.argv.count("-"):
    perror("reading from and/or writing to pipes not supported")
    sys.exit(1)

imagefile = sys.argv.pop(0)
try:
    image = Image.open(imagefile)
except IOError as error:
    perror("{0} (input): {1}".format(imagefile, error[-1]))
    sys.exit(1)
except:
    perror("{0} (input): unknown error; please report the traceback:".format(imagefile))
    raise
    sys.exit(1)

operations = 0
while len(sys.argv) > 1:
    operation = sys.argv.pop(0)
    operations += 1

    if operation == "-c":
        try:
            geometry = crop_geometry(sys.argv.pop(0), image.getbbox())
        except ValueError as error:
            perror("operation \"{0}\" ({1}): {2}".format(operation, operations, error[-1]))
            sys.exit(1)
        except TypeError as error:
            perror("operation \"{0}\" ({1}): image was damaged due to some PIL's silent bug".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)
            
        if geometry[0] == "edit":
            geometry = edit(image, geometry[1:])
        
        if geometry == None:
            perror("\"{0}\" operation canceled wia GUI".format(operation));
            sys.exit(0)

        try:
            image = image.crop(geometry)
        except MemoryError:
            perror("operation \"{0}\" ({1}): out of memory".format(operation, operations))
            sys.exit(1)
        except TypeError as error:
            perror("operation \"{0}\" ({1}): image was damaged due to some PIL's silent bug".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)

    elif operation == "-f":
        try:
            image = image.transpose(Image.FLIP_LEFT_RIGHT)
        except MemoryError:
            perror("operation \"{0}\" ({1}): out of memory".format(operation, operations))
            sys.exit(1)
        except TypeError as error:
            perror("operation \"{0}\" ({1}): image was damaged due to some PIL's silent bug".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)

    elif operation == "+f":
        try:
            image = image.transpose(Image.FLIP_TOP_BOTTOM)
        except MemoryError:
            perror("operation \"{0}\" ({1}): out of memory".format(operation, operations))
            sys.exit(1)
        except TypeError as error:
            perror("operation \"{0}\" ({1}): image was damaged due to some PIL's silent bug".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)

    elif operation == "-r":
        angle = sys.argv.pop(0)
        try:
            angle = int(angle) * -1
        except ValueError as error:
            perror("operation \"{0}\" ({1}): {2}".format(operation, operations, error[-1]))
            sys.exit(1)
        try:
            image = image.rotate(angle, Image.BICUBIC, True)
        except MemoryError:
            perror("operation \"{0}\" ({1}): out of memory".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)

    elif operation == "-s":
        try:
            geometry = resize_geometry(sys.argv.pop(0), image.getbbox())
        except ValueError as error:
            perror("operation \"{0}\" ({1}): {2}".format(operation, operations, error[-1]))
            raise
            sys.exit(1)
        except TypeError as error:
            perror("operation \"{0}\" ({1}): image was damaged due to some PIL's silent bug".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)
        try:
            image = image.resize(geometry, Image.ANTIALIAS)
        except MemoryError:
            perror("operation \"{0}\" ({1}): out of memory".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)

    else:
        perror("wrong operation \"{0}\"".format(operation))
        sys.exit(0)

try:
    imagefile = sys.argv.pop(0)
    image = image.save(imagefile)
except IOError as error:
    perror("{0} (output): {1}".format(imagefile, error[-1]))
    sys.exit(1)
except KeyError:
    perror("no output file specified")
    sys.exit(1)
except:
    perror("{0} (output): unknown error; please report the traceback:".format(imagefile))
    raise
    sys.exit(1)

# vim:set ts=4 et
