#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (c) 2011 Dmitrij D. Czarkoff <czarkoff@gmail.com>
# 
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import sys, Tkinter
from PIL import Image, ImageTk

class CropPhoto(Tkinter.Frame):
    def __init__(self, master, status, img, left, upper, right, lower, buttons=False, **kw):
        self.state = True
        self.img = img
        self.status = status

        if not buttons:
            self.status.set(1)

        self.left = left
        self.upper = upper
        self.right = right
        self.lower = lower

        self.pleft = self.left.get()
        self.pupper = self.upper.get()
        self.pright = self.right.get()
        self.plower = self.lower.get()
        
        self.bbox = img.getbbox()

        Tkinter.Frame.__init__(self, master, **kw)
        self.etop = Tkinter.Entry(self, textvariable=self.upper, width=5)
        self.etop.grid(row=0, column=1)
        
        self.eleft = Tkinter.Entry(self, textvariable=self.left, width=5)
        self.eleft.grid(row=1, column=0)

        self.canvas = Tkinter.Canvas(self, width=img.getbbox()[2], height=img.getbbox()[3])
        self.photo = ImageTk.PhotoImage(self.img)
        self.canvas.create_image(0, 0, anchor=Tkinter.NW, image = self.photo);
        self.canvas.grid(row=1, column=1)

        self.rect = self.canvas.create_rectangle(self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())
        self.canvas.bind("<B1-Motion>", self.bp)
        self.canvas.bind("<ButtonRelease-1>", self.br)

        self.eright = Tkinter.Entry(self, textvariable=self.right, width=5)
        self.eright.grid(row=1, column=2)

        self.ebottom = Tkinter.Entry(self, textvariable=self.lower, width=5)
        self.ebottom.grid(row=2, column=1)

        self.eleft.bind("<Key>", self.left_key)
        self.etop.bind("<Key>", self.upper_key)
        self.eright.bind("<Key>", self.right_key)
        self.ebottom.bind("<Key>", self.lower_key)

        self.eleft.bind("<Return>", self.left_value)
        self.etop.bind("<Return>", self.upper_value)
        self.eright.bind("<Return>", self.right_value)
        self.ebottom.bind("<Return>", self.lower_value)

        self.b_cancel = Tkinter.Button(self, text="Abort", command=self.cancel)
        self.b_crop = Tkinter.Button(self, text="Crop", command=self.crop)
        
        if buttons:
            self.b_cancel.grid(row=2, column=0)
            self.b_crop.grid(row=2, column=2)

    def chkpair(self, a, b):
        if a.get() < 0:
            b.set(b.get() + a.get())
            a.set(0)
        elif b.get() < 0:
            a.set(a.get() + b.get())
            b.set(0)

    def bp(self, event):
        canvas = event.widget   
        if self.state:
            self.state = False
            self.x = canvas.canvasx(event.x)
            self.y = canvas.canvasy(event.y)
        else:
            x = int(canvas.canvasx(event.x) - self.x)
            y = int(canvas.canvasy(event.y) - self.y)
            self.x = canvas.canvasx(event.x)
            self.y = canvas.canvasy(event.y)
            self.left.set(self.left.get() + x)
            self.upper.set(self.upper.get() + y)
            self.right.set(self.right.get() - x)
            self.lower.set(self.lower.get() - y)
            self.chkpair(self.left, self.right)
            self.chkpair(self.upper, self.lower)
            self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def br(self, event):
        self.state = True
        
    def left_value(self, event):
        self.right.set(self.right.get() - self.left.get() + self.pleft)
        self.chkpair(self.left, self.right)
        self.pleft = self.left.get()
        self.pright = self.right.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def upper_value(self, event):
        self.lower.set(self.lower.get() - self.upper.get() + self.pupper)
        self.chkpair(self.upper, self.lower)
        self.pupper = self.upper.get()
        self.plower = self.lower.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def right_value(self, event):
        self.left.set(self.left.get() - self.right.get() + self.pright)
        self.chkpair(self.left, self.right)
        self.pleft = self.left.get()
        self.pright = self.right.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def lower_value(self, event):
        self.upper.set(self.upper.get() - self.lower.get() + self.plower)
        self.chkpair(self.upper, self.lower)
        self.pupper = self.upper.get()
        self.plower = self.lower.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def left_key(self, event):
        if event.keysym == "Up":
            self.left.set(self.left.get() + 1)
        if event.keysym == "Down":
            self.left.set(self.left.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.left_value(event)

    def upper_key(self, event):
        if event.keysym == "Up":
            self.upper.set(self.upper.get() + 1)
        if event.keysym == "Down":
            self.upper.set(self.upper.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.upper_value(event)

    def right_key(self, event):
        if event.keysym == "Up":
            self.right.set(self.right.get() + 1)
        if event.keysym == "Down":
            self.right.set(self.right.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.right_value(event)

    def lower_key(self, event):
        if event.keysym == "Up":
            self.lower.set(self.lower.get() + 1)
        if event.keysym == "Down":
            self.lower.set(self.lower.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.lower_value(event)

    def cancel(self):
        self.quit()

    def crop(self):
        self.status.set(1)
        self.quit()

def edit(img, geometry):
    root = Tkinter.Tk()
    
    status = Tkinter.IntVar()
    left = Tkinter.IntVar()
    upper = Tkinter.IntVar()
    right = Tkinter.IntVar()
    lower = Tkinter.IntVar()
    
    bbox = img.getbbox()

    status.set(0)
    left.set(0)
    upper.set(0)
    right.set(bbox[2] - geometry[2])
    lower.set(bbox[2] - geometry[3])
    resizer = CropPhoto(root, status, img, left, upper, right, lower, buttons=True)
    resizer.pack()

    root.mainloop()

    if status.get() == 1:
        return (left.get(), upper.get(), bbox[2]-right.get(), bbox[3]-lower.get())
    else:
        return

def ext_geometry(spec, img):
    bbox = img.getbbox()

    if spec[-1] == "c":
        right, lower = set_geometry(spec[:-1], img)
        left = (bbox[2] - geometry[0]) / 2
        upper = (bbox[3] - geometry[1]) / 2
        right += left
        lower += upper

    elif spec.count("+") == 2:
        right, lower = set_geometry(spec[:-1], img)
        spec, upper, left = spec.split("+")
        left = int(left)
        upper = int(upper)
        right += left
        lower += upper

    elif spec.count("-") == 2:
        left, upper = set_geometry(spec[:-1], img)
        spec, lower, right = spec.split("-")
        lower = bbox[3] - int(lower)
        right = bbox[2] - int(right)
        left = right - left
        upper = lower - upper
        
    elif spec.count("+") == 0:
        return ("edit",) + bbox[2:] +  set_geometry("!" + spec, img)

    else:
        raise ValueError("Wrong value")

    return (left, upper, right, lower)

def set_geometry(spec, img):
    x = y = int()
    keep_aspect = True
    bbox = img.getbbox()
    fx = bbox[2]
    fy = bbox[3]

    if spec[0] == "!":
        spec = spec[1:]
        keep_aspect = False

    if spec.count("x") == 0:
        if spec[-1] == "%" and spec[:-1].isdigit():
            percent = int(spec[:-1])
            x = fx * percent / 100
            y = fy * percent / 100
        else:
            raise ValueError("Wrong value")
    elif spec.count("x") != 1:
        raise ValueError("Wrong value")
    else:
        x, y = spec.split("x")

        x = int(x)
        y = int(y)
        
        if keep_aspect:
            if (float(x/y) >= float(fx/fy)):
                y = int(float(fy/fx) * x)
            elif (float(x/y) <= float(fx/fy)):
                x = int(float(fx/fy) * y)

    return (x, y)

def phelp(stream=sys.stdout):
    stream.write("usage: {0} infile [-c GEOMERTY] [-r ANGLE] [-s GEOMETRY] outfile\n".format(progname))
    
def perror(error):
    sys.stderr.write(progname + ": " + error + "\n")

__version__ = "a1"

progname = sys.argv.pop(0)
if "/" in progname:
    progname = progname[progname.rindex("/")+1:]

if len(sys.argv) == 0 or sys.argv[0] == "-h":
    phelp()
    sys.exit(0)

filename = sys.argv.pop(0)
if filename == "-s" or filename == "-c":
    perror("no input file specified")
    sys.exit(1)
elif filename == "-":
    image = sys.stdin
else:
    try:
        image = open(filename, "r")
    except:
        perror("error opening the file" + filename)

image = Image.open(image)
while len(sys.argv) > 1:
    operation = sys.argv.pop(0)

    if operation == "-c":
        try:
            geometry = ext_geometry(sys.argv.pop(0), image)
        except:
            perror("no geometry provided for \"{0}\" operation".format(operation))
            sys.exit(1)
        if geometry[0] == "edit":
            geometry = edit(image, geometry[1:])
            #geometry = edit(ImageTk.PhotoImage(image), geometry[1:])
        
        if geometry == None:
            perror("\"{0}\" operation canceled wia GUI".format(operation));
            sys.exit(0)

        image = image.crop(geometry)
        image.load()

    elif operation == "-r":
        try:
            angle = sys.argv.pop(0)
        except:
            perror("no angle provided for \"{0}\" operation".format(operation))
        try:
            angle = int(angle) * -1
        except:
            perror("wrong angle \"{0}\"\n".format(geometry))
            sys.exit(1)
        image = image.rotate(angle, Image.BICUBIC, True)

    elif operation == "-s":
        try:
            geometry = set_geometry(sys.argv.pop(0), image)
        except:
            perror("no geometry provided for \"{0}\" operation".format(operation))
            sys.exit(1)
        image = image.resize(geometry, Image.ANTIALIAS)

    else:
        perror("wrong operation \"{0}\"".format(operation))
        sys.exit(0)
if len(sys.argv) == 0:
    perror("no output file specified")
    sys.exit(1)

if sys.argv[0] == filename:
    perror("infile and outfile are the same - nothing is written to disk")
    sys.exit(0)

filename = sys.argv[0]
output = open(filename, "wb")
image.save(output)

# vim:set ts=4 et
