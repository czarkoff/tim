#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (c) 2011 Dmitrij D. Czarkoff <czarkoff@gmail.com>
# 
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import os.path, re, sys, Tkinter
from PIL import Image, ImageTk

def phelp(detailed=False):
    sys.stdout.write("usage: {0} infile [-c GEOMERTY] [-r ANGLE] [-s GEOMETRY] outfile\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("options (filters):\n")
    sys.stdout.write("  -c GEOMETRY  crop an image according to a GEOMETRY specified as either\n")
    sys.stdout.write("               absolute coordinates \"{LEFT},{TOP},{BOTTOM},{RIGHT}\"\n")
    sys.stdout.write("               \"{WIDTH}x{HEIGHT}c\" to crop image from the center of image\n")
    sys.stdout.write("               or \"{WIDTH}x{HEIGHT}{+LEFT|-RIGHT}{+TOP|-BOTTOM}\"; if LEFT,\n")
    sys.stdout.write("               RIGHT, TOP and BOTTOM are ommited, the UI is brought up\n")
    sys.stdout.write("               to help You set them.\n")
    sys.stdout.write("  -r ANGLE     rotate an image ANGLE degrees clockwise (if positive value)\n")
    sys.stdout.write("               or counter clockwise (if negative)\n")
    sys.stdout.write("  -s GEOMETRY  scale an image according to a GEOMETRY spec specified as:\n")
    sys.stdout.write("               \"{WIDTH},{HEIGHT}\", \"[!]{WIDTH}x{HEIGHT}\" or \"{PERCENT}%\".\n")
    sys.stdout.write("               By default, the image is resized to fit a box with the\n")
    sys.stdout.write("               GEOMETRY specification while maintaining the aspect ratio.\n")
    sys.stdout.write("               \"!\" in the beginning of the string overrides this behaviour\n")
    if not detailed:
        sys.stdout.write("  -h           print this help (with more detailed info)\n")
        return
    sys.stdout.write("  -h           print this help\n")
    sys.stdout.write("\n")
    sys.stdout.write("Filters are applied in order specified, eg.:\n")
    sys.stdout.write("\n")
    sys.stdout.write("    {0} old.jpg -s !500x700 -r 90 -c 100x100+20+20 -s 500x700 new.png\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("will import JPEG image, scale it to 500x700 regardless initial aspect ratio,\n")
    sys.stdout.write("rotate the scaled image 90 degrees clockwise, crop rectangular area with\n")
    sys.stdout.write("coodinates (20,20)-(120,120) out of the rotated and scaled image scale it\n")
    sys.stdout.write("again to fit 500x700 box maintaining aspect ration and finaly export\n")
    sys.stdout.write("the resulting image to file new.png in PNG format.\n")
    sys.stdout.write("\n")
    sys.stdout.write("Running {0} without filters is still useful as a mean of format conversion.\n".format(progname))
    
def perror(error):
    sys.stderr.write(progname + ": " + error + "\n")

class CropPhoto(Tkinter.Frame):
    def __init__(self, master, status, img, left, upper, right, lower, buttons=False, **kw):
        self.state = True
        self.img = img
        self.status = status

        if not buttons:
            self.status.set(1)

        self.left = left
        self.upper = upper
        self.right = right
        self.lower = lower

        self.pleft = self.left.get()
        self.pupper = self.upper.get()
        self.pright = self.right.get()
        self.plower = self.lower.get()
        
        self.bbox = img.getbbox()

        Tkinter.Frame.__init__(self, master, **kw)
        self.etop = Tkinter.Entry(self, textvariable=self.upper, width=5)
        self.etop.grid(row=0, column=1)
        
        self.eleft = Tkinter.Entry(self, textvariable=self.left, width=5)
        self.eleft.grid(row=1, column=0)

        self.canvas = Tkinter.Canvas(self, width=img.getbbox()[2], height=img.getbbox()[3])
        self.photo = ImageTk.PhotoImage(self.img)
        self.canvas.create_image(0, 0, anchor=Tkinter.NW, image = self.photo);
        self.canvas.grid(row=1, column=1)

        self.rect = self.canvas.create_rectangle(self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())
        self.canvas.bind("<B1-Motion>", self.bp)
        self.canvas.bind("<ButtonRelease-1>", self.br)

        self.eright = Tkinter.Entry(self, textvariable=self.right, width=5)
        self.eright.grid(row=1, column=2)

        self.ebottom = Tkinter.Entry(self, textvariable=self.lower, width=5)
        self.ebottom.grid(row=2, column=1)

        self.eleft.bind("<Key>", self.left_key)
        self.etop.bind("<Key>", self.upper_key)
        self.eright.bind("<Key>", self.right_key)
        self.ebottom.bind("<Key>", self.lower_key)

        self.eleft.bind("<Return>", self.left_value)
        self.etop.bind("<Return>", self.upper_value)
        self.eright.bind("<Return>", self.right_value)
        self.ebottom.bind("<Return>", self.lower_value)

        self.b_cancel = Tkinter.Button(self, text="Abort", command=self.cancel)
        self.b_crop = Tkinter.Button(self, text="Crop", command=self.crop)
        
        if buttons:
            self.b_cancel.grid(row=2, column=0)
            self.b_crop.grid(row=2, column=2)

    def chkpair(self, a, b):
        if a.get() < 0:
            b.set(b.get() + a.get())
            a.set(0)
        elif b.get() < 0:
            a.set(a.get() + b.get())
            b.set(0)

    def bp(self, event):
        canvas = event.widget   
        if self.state:
            self.state = False
            self.x = canvas.canvasx(event.x)
            self.y = canvas.canvasy(event.y)
        else:
            x = int(canvas.canvasx(event.x) - self.x)
            y = int(canvas.canvasy(event.y) - self.y)
            self.x = canvas.canvasx(event.x)
            self.y = canvas.canvasy(event.y)
            self.left.set(self.left.get() + x)
            self.upper.set(self.upper.get() + y)
            self.right.set(self.right.get() - x)
            self.lower.set(self.lower.get() - y)
            self.chkpair(self.left, self.right)
            self.chkpair(self.upper, self.lower)
            self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def br(self, event):
        self.state = True
        
    def left_value(self, event):
        self.right.set(self.right.get() - self.left.get() + self.pleft)
        self.chkpair(self.left, self.right)
        self.pleft = self.left.get()
        self.pright = self.right.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def upper_value(self, event):
        self.lower.set(self.lower.get() - self.upper.get() + self.pupper)
        self.chkpair(self.upper, self.lower)
        self.pupper = self.upper.get()
        self.plower = self.lower.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def right_value(self, event):
        self.left.set(self.left.get() - self.right.get() + self.pright)
        self.chkpair(self.left, self.right)
        self.pleft = self.left.get()
        self.pright = self.right.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def lower_value(self, event):
        self.upper.set(self.upper.get() - self.lower.get() + self.plower)
        self.chkpair(self.upper, self.lower)
        self.pupper = self.upper.get()
        self.plower = self.lower.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def left_key(self, event):
        if event.keysym == "Up":
            self.left.set(self.left.get() + 1)
        if event.keysym == "Down":
            self.left.set(self.left.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.left_value(event)

    def upper_key(self, event):
        if event.keysym == "Up":
            self.upper.set(self.upper.get() + 1)
        if event.keysym == "Down":
            self.upper.set(self.upper.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.upper_value(event)

    def right_key(self, event):
        if event.keysym == "Up":
            self.right.set(self.right.get() + 1)
        if event.keysym == "Down":
            self.right.set(self.right.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.right_value(event)

    def lower_key(self, event):
        if event.keysym == "Up":
            self.lower.set(self.lower.get() + 1)
        if event.keysym == "Down":
            self.lower.set(self.lower.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.lower_value(event)

    def cancel(self):
        self.quit()

    def crop(self):
        self.status.set(1)
        self.quit()

def edit(img, geometry):
    root = Tkinter.Tk()
    
    status = Tkinter.IntVar()
    left = Tkinter.IntVar()
    upper = Tkinter.IntVar()
    right = Tkinter.IntVar()
    lower = Tkinter.IntVar()
    
    bbox = img.getbbox()
    
    status.set(0)
    left.set(0)
    upper.set(0)
    right.set(bbox[2] - geometry[0])
    lower.set(bbox[3] - geometry[1])
    resizer = CropPhoto(root, status, img, left, upper, right, lower, buttons=True)
    resizer.pack()

    root.mainloop()

    if status.get() == 1:
        return (left.get(), upper.get(), bbox[2]-right.get(), bbox[3]-lower.get())
    else:
        return

def crop_geometry(spec, bbox):
    spec = re.match("([0-9]+x[0-9]+|[0-9]+%)([\+\-][0-9]+)([\+\-][0-9]+)", spec) or re.match("([0-9]+x[0-9]+|[0-9]+%)(c)", spec) or re.match("([0-9]+x[0-9]+|[0-9]+%)", spec) or re.match("([0-9]+),([0-9]+),([0-9]+),([0-9]+)", spec)
    
    if spec != None:
        spec = spec.groups()
        if (len(spec) == 1):
            x, y = base_geometry(spec[0], bbox)

            return ("edit", x, y)

        elif (len(spec) == 2):
            x, y = base_geometry(spec[0], bbox)

            left = (bbox[2] - x) / 2
            upper = (bbox[3] - x) / 2
            right = bbox[2] - left
            lower = bbox[3] - upper

        elif (len(spec) == 3):
            x, y = base_geometry(spec[0], bbox)

            if spec[1][0] == "-":
                left = bbox[2] - x - int(spec[1][1:])
            elif spec[1][0] == "+":
                left = int(spec[1][1:])
            else:
                raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))
            right = left + x

            if spec[2][0] == "-":
                upper = bbox[3] - y - int(spec[2][1:])
            elif spec[2][0] == "+":
                upper = int(spec[2][1:])
            else:
                raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))
            lower = upper + y

        elif (len(spec) == 4):
            left = int(spec[0])
            upper = int(spec[1])
            right = int(spec[2])
            lower = int(spec[3])

        else:
            raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))
        
    else:
        raise ValueError("malformed spec \"{0}\"".format(spec))

    return (left, upper, right, lower)

def resize_geometry(spec, bbox):
    keep_aspect = True

    geometry = re.match("([0-9]+),([0-9]+)", spec)
    if geometry != None:
        x = int(geometry.group(1))
        y = int(geometry.group(2))

    else:
        spec = re.match("(!)?([0-9]+x[0-9]+)", spec) or re.match("([0-9]+%)", spec)
        
        if spec != None:
            spec = spec.groups()
        else:
            raise ValueError("malformed spec \"{0}\"".format(spec))

        if len(spec) == 1:
            keep_aspect = False
            spec = spec[0]
        elif len(spec) == 2:
            if spec[0] == "!":
                keep_aspect = False
            spec = spec[1]
        else:
            raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))

        x, y = base_geometry(spec, bbox)
        
        if keep_aspect:
            if (bbox[2]*y/bbox[3] > x):
                y = bbox[3]*x / bbox[2]
            elif (bbox[3]*x/bbox[2] > y):
                x = bbox[2]*y / bbox[3]

    return (x, y)

def base_geometry(spec, bbox):
    spec = re.match("([0-9]+)x([0-9]+)", spec) or re.match("([0-9]+)%", spec)
    if spec == None:
        raise ValueError("malformed spec \"{0}\"".format(spec))
    else:
        spec = spec.groups()
        if len(spec) == 1:
            ratio = int(spec[0])
            x = bbox[2] * ratio / 100
            y = bbox[3] * ratio / 100
        elif len(spec) == 2:
            x = int(spec[0])
            y = int(spec[1])
        else:
            raise ValueError("malformed spec \"{0}\" passed filter; please report it".format(spec))
        
    return (x, y)

__version__ = "a1"

progname = os.path.basename(sys.argv.pop(0))

if len(sys.argv) == 0:
    phelp()
    sys.exit(0)

elif sys.argv[0] == "-h":
    phelp(detailed=True)
    sys.exit(0)

if sys.argv.count("-"):
    perror("reading from and/or writing to pipes not supported")
    sys.exit(1)

imagefile = sys.argv.pop(0)
try:
    image = Image.open(imagefile)
except IOError as error:
    perror("{0} (input): {1}".format(imagefile, error[-1]))
    sys.exit(1)
except:
    perror("{0} (input): unknown error; please report the traceback:".format(imagefile))
    raise
    sys.exit(1)

operations = 0
while len(sys.argv) > 1:
    operation = sys.argv.pop(0)
    operations += 1

    if operation == "-c":
        try:
            geometry = crop_geometry(sys.argv.pop(0), image.getbbox())
        except ValueError as error:
            perror("operation \"{0}\" ({1}): {2}".format(operation, operations, error[-1]))
            sys.exit(1)
        except TypeError as error:
            perror("operation \"{0}\" ({1}): image was damaged due to some PIL's silent bug".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)
            
        if geometry[0] == "edit":
            geometry = edit(image, geometry[1:])
        
        if geometry == None:
            perror("\"{0}\" operation canceled wia GUI".format(operation));
            sys.exit(0)

        try:
            image = image.crop(geometry)
        except MemoryError:
            perror("operation \"{0}\" ({1}): out of memory".format(operation, operations))
            sys.exit(1)
        except TypeError as error:
            perror("operation \"{0}\" ({1}): image was damaged due to some PIL's silent bug".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)

    elif operation == "-r":
        angle = sys.argv.pop(0)
        try:
            angle = int(angle) * -1
        except ValueError as error:
            perror("operation \"{0}\" ({1}): {2}".format(operation, operations, error[-1]))
            sys.exit(1)
        try:
            image = image.rotate(angle, Image.BICUBIC, True)
        except MemoryError:
            perror("operation \"{0}\" ({1}): out of memory".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)

    elif operation == "-s":
        try:
            geometry = resize_geometry(sys.argv.pop(0), image.getbbox())
        except ValueError as error:
            perror("operation \"{0}\" ({1}): {2}".format(operation, operations, error[-1]))
            sys.exit(1)
        except TypeError as error:
            perror("operation \"{0}\" ({1}): image was damaged due to some PIL's silent bug".format(operation, operations))
            sys.exit(1)
        except:
            perror("{0} (input): unknown error; please report the traceback:".format(imagefile))
            raise
            sys.exit(1)
        try:
            image = image.resize(geometry, Image.ANTIALIAS)
        except MemoryError:
            perror("operation \"{0}\" ({1}): out of memory".format(operation, operations))
            sys.exit(1)
        except:
            perror("operation \"{0}\" ({1}): unknown error; please report the traceback:".format(operation, operations))
            raise
            sys.exit(1)

    else:
        perror("wrong operation \"{0}\"".format(operation))
        sys.exit(0)

try:
    imagefile = sys.argv.pop(0)
    image = image.save(imagefile)
except IOError as error:
    perror("{0} (output): {1}".format(imagefile, error[-1]))
    sys.exit(1)
except KeyError:
    perror("no output file specified")
    sys.exit(1)
except:
    perror("{0} (output): unknown error; please report the traceback:".format(imagefile))
    raise
    sys.exit(1)

# vim:set ts=4 et
