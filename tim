#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (c) 2011 Dmitrij D. Czarkoff <czarkoff@gmail.com>
# 
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import os.path, sys, Tkinter
from PIL import Image, ImageTk

class CropPhoto(Tkinter.Frame):
    def __init__(self, master, status, img, left, upper, right, lower, buttons=False, **kw):
        self.state = True
        self.img = img
        self.status = status

        if not buttons:
            self.status.set(1)

        self.left = left
        self.upper = upper
        self.right = right
        self.lower = lower

        self.pleft = self.left.get()
        self.pupper = self.upper.get()
        self.pright = self.right.get()
        self.plower = self.lower.get()
        
        self.bbox = img.getbbox()

        Tkinter.Frame.__init__(self, master, **kw)
        self.etop = Tkinter.Entry(self, textvariable=self.upper, width=5)
        self.etop.grid(row=0, column=1)
        
        self.eleft = Tkinter.Entry(self, textvariable=self.left, width=5)
        self.eleft.grid(row=1, column=0)

        self.canvas = Tkinter.Canvas(self, width=img.getbbox()[2], height=img.getbbox()[3])
        self.photo = ImageTk.PhotoImage(self.img)
        self.canvas.create_image(0, 0, anchor=Tkinter.NW, image = self.photo);
        self.canvas.grid(row=1, column=1)

        self.rect = self.canvas.create_rectangle(self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())
        self.canvas.bind("<B1-Motion>", self.bp)
        self.canvas.bind("<ButtonRelease-1>", self.br)

        self.eright = Tkinter.Entry(self, textvariable=self.right, width=5)
        self.eright.grid(row=1, column=2)

        self.ebottom = Tkinter.Entry(self, textvariable=self.lower, width=5)
        self.ebottom.grid(row=2, column=1)

        self.eleft.bind("<Key>", self.left_key)
        self.etop.bind("<Key>", self.upper_key)
        self.eright.bind("<Key>", self.right_key)
        self.ebottom.bind("<Key>", self.lower_key)

        self.eleft.bind("<Return>", self.left_value)
        self.etop.bind("<Return>", self.upper_value)
        self.eright.bind("<Return>", self.right_value)
        self.ebottom.bind("<Return>", self.lower_value)

        self.b_cancel = Tkinter.Button(self, text="Abort", command=self.cancel)
        self.b_crop = Tkinter.Button(self, text="Crop", command=self.crop)
        
        if buttons:
            self.b_cancel.grid(row=2, column=0)
            self.b_crop.grid(row=2, column=2)

    def chkpair(self, a, b):
        if a.get() < 0:
            b.set(b.get() + a.get())
            a.set(0)
        elif b.get() < 0:
            a.set(a.get() + b.get())
            b.set(0)

    def bp(self, event):
        canvas = event.widget   
        if self.state:
            self.state = False
            self.x = canvas.canvasx(event.x)
            self.y = canvas.canvasy(event.y)
        else:
            x = int(canvas.canvasx(event.x) - self.x)
            y = int(canvas.canvasy(event.y) - self.y)
            self.x = canvas.canvasx(event.x)
            self.y = canvas.canvasy(event.y)
            self.left.set(self.left.get() + x)
            self.upper.set(self.upper.get() + y)
            self.right.set(self.right.get() - x)
            self.lower.set(self.lower.get() - y)
            self.chkpair(self.left, self.right)
            self.chkpair(self.upper, self.lower)
            self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def br(self, event):
        self.state = True
        
    def left_value(self, event):
        self.right.set(self.right.get() - self.left.get() + self.pleft)
        self.chkpair(self.left, self.right)
        self.pleft = self.left.get()
        self.pright = self.right.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def upper_value(self, event):
        self.lower.set(self.lower.get() - self.upper.get() + self.pupper)
        self.chkpair(self.upper, self.lower)
        self.pupper = self.upper.get()
        self.plower = self.lower.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def right_value(self, event):
        self.left.set(self.left.get() - self.right.get() + self.pright)
        self.chkpair(self.left, self.right)
        self.pleft = self.left.get()
        self.pright = self.right.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def lower_value(self, event):
        self.upper.set(self.upper.get() - self.lower.get() + self.plower)
        self.chkpair(self.upper, self.lower)
        self.pupper = self.upper.get()
        self.plower = self.lower.get()
        self.canvas.coords(self.rect, self.left.get(), self.upper.get(), self.bbox[2]-self.right.get(), self.bbox[3]-self.lower.get())

    def left_key(self, event):
        if event.keysym == "Up":
            self.left.set(self.left.get() + 1)
        if event.keysym == "Down":
            self.left.set(self.left.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.left_value(event)

    def upper_key(self, event):
        if event.keysym == "Up":
            self.upper.set(self.upper.get() + 1)
        if event.keysym == "Down":
            self.upper.set(self.upper.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.upper_value(event)

    def right_key(self, event):
        if event.keysym == "Up":
            self.right.set(self.right.get() + 1)
        if event.keysym == "Down":
            self.right.set(self.right.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.right_value(event)

    def lower_key(self, event):
        if event.keysym == "Up":
            self.lower.set(self.lower.get() + 1)
        if event.keysym == "Down":
            self.lower.set(self.lower.get() - 1)
        if event.keysym == "Up" or event.keysym == "Down" or event.keysym == "Tab":
            self.lower_value(event)

    def cancel(self):
        self.quit()

    def crop(self):
        self.status.set(1)
        self.quit()

def edit(img, geometry):
    root = Tkinter.Tk()
    
    status = Tkinter.IntVar()
    left = Tkinter.IntVar()
    upper = Tkinter.IntVar()
    right = Tkinter.IntVar()
    lower = Tkinter.IntVar()
    
    bbox = img.getbbox()

    status.set(0)
    left.set(0)
    upper.set(0)
    right.set(bbox[2] - geometry[2])
    lower.set(bbox[2] - geometry[3])
    resizer = CropPhoto(root, status, img, left, upper, right, lower, buttons=True)
    resizer.pack()

    root.mainloop()

    if status.get() == 1:
        return (left.get(), upper.get(), bbox[2]-right.get(), bbox[3]-lower.get())
    else:
        return

def ext_geometry(spec, img):
    bbox = img.getbbox()

    if spec[-1] == "c":
        right, lower = set_geometry(spec[:-1], img)
        left = (bbox[2] - geometry[0]) / 2
        upper = (bbox[3] - geometry[1]) / 2
        right += left
        lower += upper

    elif spec.count("+") == 2:
        right, lower = set_geometry(spec[:spec.index("+")], img)
        spec, upper, left = spec.split("+")
        left = int(left)
        upper = int(upper)
        right += left
        lower += upper

    elif spec.count("-") == 2:
        left, upper = set_geometry(spec[:-1], img)
        spec, lower, right = spec.split("-")
        lower = bbox[3] - int(lower)
        right = bbox[2] - int(right)
        left = right - left
        upper = lower - upper
        
    elif spec.count("+") == 0:
        return ("edit",) + bbox[2:] +  set_geometry("!" + spec, img)

    else:
        raise ValueError("Wrong value")

    return (left, upper, right, lower)

def set_geometry(spec, img):
    x = y = int()
    keep_aspect = True
    bbox = img.getbbox()
    fx = bbox[2]
    fy = bbox[3]

    if spec[0] == "!":
        spec = spec[1:]
        keep_aspect = False

    if spec.count("x") == 0:
        if spec[-1] == "%":
            percent = int(spec[:-1])
            x = fx * percent / 100
            y = fy * percent / 100
        else:
            raise ValueError("malformed spec \"{0}\"".format(spec))
    elif spec.count("x") > 1:
        raise ValueError("malformed spec \"{0}\"".format(spec))
    else:
        x, y = spec.split("x")

        x = int(x)
        y = int(y)
        
        if keep_aspect:
            if (float(x/y) >= float(fx/fy)):
                y = int(float(fy/fx) * x)
            elif (float(x/y) <= float(fx/fy)):
                x = int(float(fx/fy) * y)

    return (x, y)

def phelp(detailed=False):
    sys.stdout.write("usage: {0} infile [-c GEOMERTY] [-r ANGLE] [-s GEOMETRY] outfile\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("options (filters):\n")
    sys.stdout.write("  -c GEOMETRY  crop an image according to a GEOMETRY spec specified as:\n")
    sys.stdout.write("               \"WIDTHxHEIGHT[+LEFT+TOP]\"; if LEFT and TOP are ommited,\n")
    sys.stdout.write("               the UI is brought up to help You set them.\n")
    sys.stdout.write("  -r ANGLE     rotate an image ANGLE degrees clockwise (if positive value)\n")
    sys.stdout.write("               or counter clockwise (if negative)\n")
    sys.stdout.write("  -s GEOMETRY  scale an image according to a GEOMETRY spec specified as:\n")
    sys.stdout.write("               [!]WIDTHxHEIGHT or PERCENT%.\n")
    sys.stdout.write("               By default, the image is resized to fit a box with the\n")
    sys.stdout.write("               GEOMETRY specification while maintaining the aspect ratio.\n")
    sys.stdout.write("               \"!\" in the beginning of the string overrides this behaviour\n")
    if not detailed:
        sys.stdout.write("  -h           print this help (with more detailed info)\n")
        return
    sys.stdout.write("  -h           print this help\n")
    sys.stdout.write("\n")
    sys.stdout.write("Filters are applied in order specified, eg.:\n")
    sys.stdout.write("\n")
    sys.stdout.write("    {0} old.jpg -s !500x700 -r 90 -c 100x100+20+20 -s 500x700 new.png\n".format(progname))
    sys.stdout.write("\n")
    sys.stdout.write("will import JPEG image, scale it to 500x700 regardless initial aspect ratio,\n")
    sys.stdout.write("rotate the scaled image 90 degrees clockwise, crop rectangular area with\n")
    sys.stdout.write("coodinates (20,20)-(120,120) out of the rotated and scaled image scale it\n")
    sys.stdout.write("again to fit 500x700 box maintaining aspect ration and finaly export\n")
    sys.stdout.write("the resulting image to file new.png in PNG format.\n")
    sys.stdout.write("\n")
    sys.stdout.write("Running {0} without filters is still useful as a mean of format conversion.\n".format(progname))
    
def perror(error):
    sys.stderr.write(progname + ": " + error + "\n")

__version__ = "a1"

progname = os.path.basename(sys.argv.pop(0))

if len(sys.argv) == 0:
    phelp()
    sys.exit(0)

elif sys.argv[0] == "-h":
    phelp(detailed=True)
    sys.exit(0)

if sys.argv.count("-"):
    perror("reading from and/or writing to pipes not supported")
    sys.exit(1)

imagefile = sys.argv.pop(0)
try:
    image = Image.open(imagefile)
except IOError as error:
    perror("{0} (input): {1}".format(imagefile, error[-1]))
    sys.exit(1)
except:
    perror("{0} (input): unknown error; please report the traceback:".format(imagefile))
    raise
    sys.exit(1)

operations = 0
while len(sys.argv) > 1:
    operation = sys.argv.pop(0)
    operations += 1

    if operation == "-c":
        try:
            geometry = ext_geometry(sys.argv.pop(0), image)
        except ValueError as error:
            perror("operation \"{0}\" ({1}): {2}".format(operation, operations, error[-1]))
            sys.exit(1)
        except:
            perror("{0} (input): unknown error; please report the traceback:".format(imagefile))
            raise
            sys.exit(1)
            
        if geometry[0] == "edit":
            geometry = edit(image, geometry[1:])
        
        if geometry == None:
            perror("\"{0}\" operation canceled wia GUI".format(operation));
            sys.exit(0)

        image = image.crop(geometry)
        image.load()

    elif operation == "-r":
        angle = sys.argv.pop(0)
        try:
            angle = int(angle) * -1
        except ValueError as error:
            perror("operation \"{0}\" ({1}): {2}".format(operation, operations, error[-1]))
            sys.exit(1)
        image = image.rotate(angle, Image.BICUBIC, True)

    elif operation == "-s":
        try:
            geometry = set_geometry(sys.argv.pop(0), image)
        except ValueError as error:
            perror("operation \"{0}\" ({1}): {2}".format(operation, operations, error[-1]))
            sys.exit(1)
        except:
            perror("{0} (input): unknown error; please report the traceback:".format(imagefile))
            raise
            sys.exit(1)
        image = image.resize(geometry, Image.ANTIALIAS)

    else:
        perror("wrong operation \"{0}\"".format(operation))
        sys.exit(0)

try:
    imagefile = sys.argv.pop(0)
    image = image.save(imagefile)
except IOError as error:
    perror("{0} (output): {1}".format(imagefile, error[-1]))
    sys.exit(1)
except KeyError:
    perror("no output file specified")
    sys.exit(1)
except:
    perror("{0} (output): unknown error; please report the traceback:".format(imagefile))
    raise
    sys.exit(1)

# vim:set ts=4 et
